(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/three/examples/jsm/controls/DragControls.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DragControls",
    ()=>DragControls
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
const _pointer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _diff = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _previousPointer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _intersection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _worldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _inverseMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _right = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
let _selected = null, _hovered = null;
const _intersections = [];
const STATE = {
    NONE: -1,
    PAN: 0,
    ROTATE: 1
};
/**
 * This class can be used to provide a drag'n'drop interaction.
 *
 * ```js
 * const controls = new DragControls( objects, camera, renderer.domElement );
 *
 * // add event listener to highlight dragged objects
 * controls.addEventListener( 'dragstart', function ( event ) {
 *
 * 	event.object.material.emissive.set( 0xaaaaaa );
 *
 * } );
 *
 * controls.addEventListener( 'dragend', function ( event ) {
 *
 * 	event.object.material.emissive.set( 0x000000 );
 *
 * } );
 * ```
 *
 * @augments Controls
 * @three_import import { DragControls } from 'three/addons/controls/DragControls.js';
 */ class DragControls extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Controls"] {
    /**
	 * Constructs a new controls instance.
	 *
	 * @param {Array<Object3D>} objects - An array of draggable 3D objects.
	 * @param {Camera} camera - The camera of the rendered scene.
	 * @param {?HTMLElement} [domElement=null] - The HTML DOM element used for event listeners.
	 */ constructor(objects, camera, domElement = null){
        super(camera, domElement);
        /**
		 * An array of draggable 3D objects.
		 *
		 * @type {Array<Object3D>}
		 */ this.objects = objects;
        /**
		 * Whether children of draggable objects can be dragged independently from their parent.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.recursive = true;
        /**
		 * This option only works if the `objects` array contains a single draggable  group object.
		 * If set to `true`, the controls does not transform individual objects but the entire group.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.transformGroup = false;
        /**
		 * The speed at which the object will rotate when dragged in `rotate` mode.
		 * The higher the number the faster the rotation.
		 *
		 * @type {number}
		 * @default 1
		 */ this.rotateSpeed = 1;
        /**
		 * The raycaster used for detecting 3D objects.
		 *
		 * @type {Raycaster}
		 */ this.raycaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Raycaster"]();
        // interaction
        this.mouseButtons = {
            LEFT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN,
            MIDDLE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN,
            RIGHT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE
        };
        this.touches = {
            ONE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].PAN
        };
        // event listeners
        this._onPointerMove = onPointerMove.bind(this);
        this._onPointerDown = onPointerDown.bind(this);
        this._onPointerCancel = onPointerCancel.bind(this);
        this._onContextMenu = onContextMenu.bind(this);
        //
        if (domElement !== null) {
            this.connect(domElement);
        }
    }
    connect(element) {
        super.connect(element);
        this.domElement.addEventListener('pointermove', this._onPointerMove);
        this.domElement.addEventListener('pointerdown', this._onPointerDown);
        this.domElement.addEventListener('pointerup', this._onPointerCancel);
        this.domElement.addEventListener('pointerleave', this._onPointerCancel);
        this.domElement.addEventListener('contextmenu', this._onContextMenu);
        this.domElement.style.touchAction = 'none'; // disable touch scroll
    }
    disconnect() {
        this.domElement.removeEventListener('pointermove', this._onPointerMove);
        this.domElement.removeEventListener('pointerdown', this._onPointerDown);
        this.domElement.removeEventListener('pointerup', this._onPointerCancel);
        this.domElement.removeEventListener('pointerleave', this._onPointerCancel);
        this.domElement.removeEventListener('contextmenu', this._onContextMenu);
        this.domElement.style.touchAction = 'auto';
        this.domElement.style.cursor = '';
    }
    dispose() {
        this.disconnect();
    }
    _updatePointer(event) {
        const rect = this.domElement.getBoundingClientRect();
        _pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
        _pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
    }
    _updateState(event) {
        // determine action
        let action;
        if (event.pointerType === 'touch') {
            action = this.touches.ONE;
        } else {
            switch(event.button){
                case 0:
                    action = this.mouseButtons.LEFT;
                    break;
                case 1:
                    action = this.mouseButtons.MIDDLE;
                    break;
                case 2:
                    action = this.mouseButtons.RIGHT;
                    break;
                default:
                    action = null;
            }
        }
        // determine state
        switch(action){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].PAN:
                this.state = STATE.PAN;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].ROTATE:
                this.state = STATE.ROTATE;
                break;
            default:
                this.state = STATE.NONE;
        }
    }
}
function onPointerMove(event) {
    const camera = this.object;
    const domElement = this.domElement;
    const raycaster = this.raycaster;
    if (this.enabled === false) return;
    this._updatePointer(event);
    raycaster.setFromCamera(_pointer, camera);
    if (_selected) {
        if (this.state === STATE.PAN) {
            if (raycaster.ray.intersectPlane(_plane, _intersection)) {
                _selected.position.copy(_intersection.sub(_offset).applyMatrix4(_inverseMatrix));
                this.dispatchEvent({
                    type: 'drag',
                    object: _selected
                });
            }
        } else if (this.state === STATE.ROTATE) {
            _diff.subVectors(_pointer, _previousPointer).multiplyScalar(this.rotateSpeed);
            _selected.rotateOnWorldAxis(_up, _diff.x);
            _selected.rotateOnWorldAxis(_right.normalize(), -_diff.y);
            this.dispatchEvent({
                type: 'drag',
                object: _selected
            });
        }
        _previousPointer.copy(_pointer);
    } else {
        // hover support
        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
            _intersections.length = 0;
            raycaster.setFromCamera(_pointer, camera);
            raycaster.intersectObjects(this.objects, this.recursive, _intersections);
            if (_intersections.length > 0) {
                const object = _intersections[0].object;
                _plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(object.matrixWorld));
                if (_hovered !== object && _hovered !== null) {
                    this.dispatchEvent({
                        type: 'hoveroff',
                        object: _hovered
                    });
                    domElement.style.cursor = 'auto';
                    _hovered = null;
                }
                if (_hovered !== object) {
                    this.dispatchEvent({
                        type: 'hoveron',
                        object: object
                    });
                    domElement.style.cursor = 'pointer';
                    _hovered = object;
                }
            } else {
                if (_hovered !== null) {
                    this.dispatchEvent({
                        type: 'hoveroff',
                        object: _hovered
                    });
                    domElement.style.cursor = 'auto';
                    _hovered = null;
                }
            }
        }
    }
    _previousPointer.copy(_pointer);
}
function onPointerDown(event) {
    const camera = this.object;
    const domElement = this.domElement;
    const raycaster = this.raycaster;
    if (this.enabled === false) return;
    this._updatePointer(event);
    this._updateState(event);
    _intersections.length = 0;
    raycaster.setFromCamera(_pointer, camera);
    raycaster.intersectObjects(this.objects, this.recursive, _intersections);
    if (_intersections.length > 0) {
        if (this.transformGroup === true) {
            // look for the outermost group in the object's upper hierarchy
            _selected = findGroup(_intersections[0].object);
        } else {
            _selected = _intersections[0].object;
        }
        _plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(_plane.normal), _worldPosition.setFromMatrixPosition(_selected.matrixWorld));
        if (raycaster.ray.intersectPlane(_plane, _intersection)) {
            if (this.state === STATE.PAN) {
                _inverseMatrix.copy(_selected.parent.matrixWorld).invert();
                _offset.copy(_intersection).sub(_worldPosition.setFromMatrixPosition(_selected.matrixWorld));
                domElement.style.cursor = 'move';
                this.dispatchEvent({
                    type: 'dragstart',
                    object: _selected
                });
            } else if (this.state === STATE.ROTATE) {
                // the controls only support Y+ up
                _up.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
                _right.set(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
                domElement.style.cursor = 'move';
                this.dispatchEvent({
                    type: 'dragstart',
                    object: _selected
                });
            }
        }
    }
    _previousPointer.copy(_pointer);
}
function onPointerCancel() {
    if (this.enabled === false) return;
    if (_selected) {
        this.dispatchEvent({
            type: 'dragend',
            object: _selected
        });
        _selected = null;
    }
    this.domElement.style.cursor = _hovered ? 'pointer' : 'auto';
    this.state = STATE.NONE;
}
function onContextMenu(event) {
    if (this.enabled === false) return;
    event.preventDefault();
}
function findGroup(obj, group = null) {
    if (obj.isGroup) group = obj;
    if (obj.parent === null) return group;
    return findGroup(obj.parent, group);
}
;
}),
"[project]/node_modules/three/examples/jsm/controls/TrackballControls.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TrackballControls",
    ()=>TrackballControls
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
/**
 * Fires when the camera has been transformed by the controls.
 *
 * @event TrackballControls#change
 * @type {Object}
 */ const _changeEvent = {
    type: 'change'
};
/**
 * Fires when an interaction was initiated.
 *
 * @event TrackballControls#start
 * @type {Object}
 */ const _startEvent = {
    type: 'start'
};
/**
 * Fires when an interaction has finished.
 *
 * @event TrackballControls#end
 * @type {Object}
 */ const _endEvent = {
    type: 'end'
};
const _EPS = 0.000001;
const _STATE = {
    NONE: -1,
    ROTATE: 0,
    ZOOM: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_ZOOM_PAN: 4
};
const _v2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _mouseChange = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _objectUp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _pan = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _axis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _eyeDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _objectUpDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _objectSidewaysDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _moveDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
/**
 * This class is similar to {@link OrbitControls}. However, it does not maintain a constant camera
 * `up` vector. That means if the camera orbits over the “north” and “south” poles, it does not flip
 * to stay "right side up".
 *
 * @augments Controls
 * @three_import import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 */ class TrackballControls extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Controls"] {
    /**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	 */ constructor(object, domElement = null){
        super(object, domElement);
        /**
		 * Represents the properties of the screen. Automatically set when `handleResize()` is called.
		 *
		 * @type {Object}
		 * @readonly
		 */ this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        };
        /**
		 * The rotation speed.
		 *
		 * @type {number}
		 * @default 1
		 */ this.rotateSpeed = 1.0;
        /**
		 * The zoom speed.
		 *
		 * @type {number}
		 * @default 1.2
		 */ this.zoomSpeed = 1.2;
        /**
		 * The pan speed.
		 *
		 * @type {number}
		 * @default 0.3
		 */ this.panSpeed = 0.3;
        /**
		 * Whether rotation is disabled or not.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.noRotate = false;
        /**
		 * Whether zooming is disabled or not.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.noZoom = false;
        /**
		 * Whether panning is disabled or not.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.noPan = false;
        /**
		 * Whether damping is disabled or not.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.staticMoving = false;
        /**
		 * Defines the intensity of damping. Only considered if `staticMoving` is set to `false`.
		 *
		 * @type {number}
		 * @default 0.2
		 */ this.dynamicDampingFactor = 0.2;
        /**
		 * How far you can dolly in (perspective camera only).
		 *
		 * @type {number}
		 * @default 0
		 */ this.minDistance = 0;
        /**
		 * How far you can dolly out (perspective camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */ this.maxDistance = Infinity;
        /**
		 * How far you can zoom in (orthographic camera only).
		 *
		 * @type {number}
		 * @default 0
		 */ this.minZoom = 0;
        /**
		 * How far you can zoom out (orthographic camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */ this.maxZoom = Infinity;
        /**
		 * This array holds keycodes for controlling interactions.
		 *
		 * - When the first defined key is pressed, all mouse interactions (left, middle, right) performs orbiting.
		 * - When the second defined key is pressed, all mouse interactions (left, middle, right) performs zooming.
		 * - When the third defined key is pressed, all mouse interactions (left, middle, right) performs panning.
		 *
		 * Default is *KeyA, KeyS, KeyD* which represents A, S, D.
		 *
		 * @type {Array<string>}
		 */ this.keys = [
            'KeyA' /*A*/ ,
            'KeyS' /*S*/ ,
            'KeyD' /*D*/ 
        ];
        /**
		 * This object contains references to the mouse actions used by the controls.
		 *
		 * ```js
		 * controls.mouseButtons = {
		 * 	LEFT: THREE.MOUSE.ROTATE,
		 * 	MIDDLE: THREE.MOUSE.DOLLY,
		 * 	RIGHT: THREE.MOUSE.PAN
		 * }
		 * ```
		 * @type {Object}
		 */ this.mouseButtons = {
            LEFT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE,
            MIDDLE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].DOLLY,
            RIGHT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN
        };
        /**
		 * The focus point of the controls.
		 *
		 * @type {Vector3}
		 */ this.target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        // internals
        this.state = _STATE.NONE;
        this.keyState = _STATE.NONE;
        this._lastPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lastZoom = 1;
        this._touchZoomDistanceStart = 0;
        this._touchZoomDistanceEnd = 0;
        this._lastAngle = 0;
        this._eye = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._movePrev = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._moveCurr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._lastAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._zoomStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._zoomEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._panStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._panEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._pointers = [];
        this._pointerPositions = {};
        // event listeners
        this._onPointerMove = onPointerMove.bind(this);
        this._onPointerDown = onPointerDown.bind(this);
        this._onPointerUp = onPointerUp.bind(this);
        this._onPointerCancel = onPointerCancel.bind(this);
        this._onContextMenu = onContextMenu.bind(this);
        this._onMouseWheel = onMouseWheel.bind(this);
        this._onKeyDown = onKeyDown.bind(this);
        this._onKeyUp = onKeyUp.bind(this);
        this._onTouchStart = onTouchStart.bind(this);
        this._onTouchMove = onTouchMove.bind(this);
        this._onTouchEnd = onTouchEnd.bind(this);
        this._onMouseDown = onMouseDown.bind(this);
        this._onMouseMove = onMouseMove.bind(this);
        this._onMouseUp = onMouseUp.bind(this);
        // for reset
        this._target0 = this.target.clone();
        this._position0 = this.object.position.clone();
        this._up0 = this.object.up.clone();
        this._zoom0 = this.object.zoom;
        if (domElement !== null) {
            this.connect(domElement);
            this.handleResize();
        }
        // force an update at start
        this.update();
    }
    connect(element) {
        super.connect(element);
        window.addEventListener('keydown', this._onKeyDown);
        window.addEventListener('keyup', this._onKeyUp);
        this.domElement.addEventListener('pointerdown', this._onPointerDown);
        this.domElement.addEventListener('pointercancel', this._onPointerCancel);
        this.domElement.addEventListener('wheel', this._onMouseWheel, {
            passive: false
        });
        this.domElement.addEventListener('contextmenu', this._onContextMenu);
        this.domElement.style.touchAction = 'none'; // disable touch scroll
    }
    disconnect() {
        window.removeEventListener('keydown', this._onKeyDown);
        window.removeEventListener('keyup', this._onKeyUp);
        this.domElement.removeEventListener('pointerdown', this._onPointerDown);
        this.domElement.ownerDocument.removeEventListener('pointermove', this._onPointerMove);
        this.domElement.ownerDocument.removeEventListener('pointerup', this._onPointerUp);
        this.domElement.removeEventListener('pointercancel', this._onPointerCancel);
        this.domElement.removeEventListener('wheel', this._onMouseWheel);
        this.domElement.removeEventListener('contextmenu', this._onContextMenu);
        this.domElement.style.touchAction = 'auto'; // disable touch scroll
    }
    dispose() {
        this.disconnect();
    }
    /**
	 * Must be called if the application window is resized.
	 */ handleResize() {
        const box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        const d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
    }
    update() {
        this._eye.subVectors(this.object.position, this.target);
        if (!this.noRotate) {
            this._rotateCamera();
        }
        if (!this.noZoom) {
            this._zoomCamera();
        }
        if (!this.noPan) {
            this._panCamera();
        }
        this.object.position.addVectors(this.target, this._eye);
        if (this.object.isPerspectiveCamera) {
            this._checkDistances();
            this.object.lookAt(this.target);
            if (this._lastPosition.distanceToSquared(this.object.position) > _EPS) {
                this.dispatchEvent(_changeEvent);
                this._lastPosition.copy(this.object.position);
            }
        } else if (this.object.isOrthographicCamera) {
            this.object.lookAt(this.target);
            if (this._lastPosition.distanceToSquared(this.object.position) > _EPS || this._lastZoom !== this.object.zoom) {
                this.dispatchEvent(_changeEvent);
                this._lastPosition.copy(this.object.position);
                this._lastZoom = this.object.zoom;
            }
        } else {
            console.warn('THREE.TrackballControls: Unsupported camera type.');
        }
    }
    /**
	 * Resets the controls to its initial state.
	 */ reset() {
        this.state = _STATE.NONE;
        this.keyState = _STATE.NONE;
        this.target.copy(this._target0);
        this.object.position.copy(this._position0);
        this.object.up.copy(this._up0);
        this.object.zoom = this._zoom0;
        this.object.updateProjectionMatrix();
        this._eye.subVectors(this.object.position, this.target);
        this.object.lookAt(this.target);
        this.dispatchEvent(_changeEvent);
        this._lastPosition.copy(this.object.position);
        this._lastZoom = this.object.zoom;
    }
    _panCamera() {
        _mouseChange.copy(this._panEnd).sub(this._panStart);
        if (_mouseChange.lengthSq()) {
            if (this.object.isOrthographicCamera) {
                const scale_x = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth;
                const scale_y = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
                _mouseChange.x *= scale_x;
                _mouseChange.y *= scale_y;
            }
            _mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);
            _pan.copy(this._eye).cross(this.object.up).setLength(_mouseChange.x);
            _pan.add(_objectUp.copy(this.object.up).setLength(_mouseChange.y));
            this.object.position.add(_pan);
            this.target.add(_pan);
            if (this.staticMoving) {
                this._panStart.copy(this._panEnd);
            } else {
                this._panStart.add(_mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
            }
        }
    }
    _rotateCamera() {
        _moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
        let angle = _moveDirection.length();
        if (angle) {
            this._eye.copy(this.object.position).sub(this.target);
            _eyeDirection.copy(this._eye).normalize();
            _objectUpDirection.copy(this.object.up).normalize();
            _objectSidewaysDirection.crossVectors(_objectUpDirection, _eyeDirection).normalize();
            _objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);
            _objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);
            _moveDirection.copy(_objectUpDirection.add(_objectSidewaysDirection));
            _axis.crossVectors(_moveDirection, this._eye).normalize();
            angle *= this.rotateSpeed;
            _quaternion.setFromAxisAngle(_axis, angle);
            this._eye.applyQuaternion(_quaternion);
            this.object.up.applyQuaternion(_quaternion);
            this._lastAxis.copy(_axis);
            this._lastAngle = angle;
        } else if (!this.staticMoving && this._lastAngle) {
            this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);
            this._eye.copy(this.object.position).sub(this.target);
            _quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);
            this._eye.applyQuaternion(_quaternion);
            this.object.up.applyQuaternion(_quaternion);
        }
        this._movePrev.copy(this._moveCurr);
    }
    _zoomCamera() {
        let factor;
        if (this.state === _STATE.TOUCH_ZOOM_PAN) {
            factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
            this._touchZoomDistanceStart = this._touchZoomDistanceEnd;
            if (this.object.isPerspectiveCamera) {
                this._eye.multiplyScalar(factor);
            } else if (this.object.isOrthographicCamera) {
                this.object.zoom = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
                if (this._lastZoom !== this.object.zoom) {
                    this.object.updateProjectionMatrix();
                }
            } else {
                console.warn('THREE.TrackballControls: Unsupported camera type');
            }
        } else {
            factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;
            if (factor !== 1.0 && factor > 0.0) {
                if (this.object.isPerspectiveCamera) {
                    this._eye.multiplyScalar(factor);
                } else if (this.object.isOrthographicCamera) {
                    this.object.zoom = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.object.zoom / factor, this.minZoom, this.maxZoom);
                    if (this._lastZoom !== this.object.zoom) {
                        this.object.updateProjectionMatrix();
                    }
                } else {
                    console.warn('THREE.TrackballControls: Unsupported camera type');
                }
            }
            if (this.staticMoving) {
                this._zoomStart.copy(this._zoomEnd);
            } else {
                this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;
            }
        }
    }
    _getMouseOnScreen(pageX, pageY) {
        _v2.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);
        return _v2;
    }
    _getMouseOnCircle(pageX, pageY) {
        _v2.set((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5), (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width);
        return _v2;
    }
    _addPointer(event) {
        this._pointers.push(event);
    }
    _removePointer(event) {
        delete this._pointerPositions[event.pointerId];
        for(let i = 0; i < this._pointers.length; i++){
            if (this._pointers[i].pointerId == event.pointerId) {
                this._pointers.splice(i, 1);
                return;
            }
        }
    }
    _trackPointer(event) {
        let position = this._pointerPositions[event.pointerId];
        if (position === undefined) {
            position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
            this._pointerPositions[event.pointerId] = position;
        }
        position.set(event.pageX, event.pageY);
    }
    _getSecondPointerPosition(event) {
        const pointer = event.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
        return this._pointerPositions[pointer.pointerId];
    }
    _checkDistances() {
        if (!this.noZoom || !this.noPan) {
            if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {
                this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));
                this._zoomStart.copy(this._zoomEnd);
            }
            if (this._eye.lengthSq() < this.minDistance * this.minDistance) {
                this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));
                this._zoomStart.copy(this._zoomEnd);
            }
        }
    }
}
function onPointerDown(event) {
    if (this.enabled === false) return;
    if (this._pointers.length === 0) {
        this.domElement.setPointerCapture(event.pointerId);
        this.domElement.ownerDocument.addEventListener('pointermove', this._onPointerMove);
        this.domElement.ownerDocument.addEventListener('pointerup', this._onPointerUp);
    }
    //
    this._addPointer(event);
    if (event.pointerType === 'touch') {
        this._onTouchStart(event);
    } else {
        this._onMouseDown(event);
    }
}
function onPointerMove(event) {
    if (this.enabled === false) return;
    if (event.pointerType === 'touch') {
        this._onTouchMove(event);
    } else {
        this._onMouseMove(event);
    }
}
function onPointerUp(event) {
    if (this.enabled === false) return;
    if (event.pointerType === 'touch') {
        this._onTouchEnd(event);
    } else {
        this._onMouseUp();
    }
    //
    this._removePointer(event);
    if (this._pointers.length === 0) {
        this.domElement.releasePointerCapture(event.pointerId);
        this.domElement.ownerDocument.removeEventListener('pointermove', this._onPointerMove);
        this.domElement.ownerDocument.removeEventListener('pointerup', this._onPointerUp);
    }
}
function onPointerCancel(event) {
    this._removePointer(event);
}
function onKeyUp() {
    if (this.enabled === false) return;
    this.keyState = _STATE.NONE;
    window.addEventListener('keydown', this._onKeyDown);
}
function onKeyDown(event) {
    if (this.enabled === false) return;
    window.removeEventListener('keydown', this._onKeyDown);
    if (this.keyState !== _STATE.NONE) {
        return;
    } else if (event.code === this.keys[_STATE.ROTATE] && !this.noRotate) {
        this.keyState = _STATE.ROTATE;
    } else if (event.code === this.keys[_STATE.ZOOM] && !this.noZoom) {
        this.keyState = _STATE.ZOOM;
    } else if (event.code === this.keys[_STATE.PAN] && !this.noPan) {
        this.keyState = _STATE.PAN;
    }
}
function onMouseDown(event) {
    let mouseAction;
    switch(event.button){
        case 0:
            mouseAction = this.mouseButtons.LEFT;
            break;
        case 1:
            mouseAction = this.mouseButtons.MIDDLE;
            break;
        case 2:
            mouseAction = this.mouseButtons.RIGHT;
            break;
        default:
            mouseAction = -1;
    }
    switch(mouseAction){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].DOLLY:
            this.state = _STATE.ZOOM;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE:
            this.state = _STATE.ROTATE;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN:
            this.state = _STATE.PAN;
            break;
        default:
            this.state = _STATE.NONE;
    }
    const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
    if (state === _STATE.ROTATE && !this.noRotate) {
        this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
        this._movePrev.copy(this._moveCurr);
    } else if (state === _STATE.ZOOM && !this.noZoom) {
        this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
        this._zoomEnd.copy(this._zoomStart);
    } else if (state === _STATE.PAN && !this.noPan) {
        this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));
        this._panEnd.copy(this._panStart);
    }
    this.dispatchEvent(_startEvent);
}
function onMouseMove(event) {
    const state = this.keyState !== _STATE.NONE ? this.keyState : this.state;
    if (state === _STATE.ROTATE && !this.noRotate) {
        this._movePrev.copy(this._moveCurr);
        this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
    } else if (state === _STATE.ZOOM && !this.noZoom) {
        this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    } else if (state === _STATE.PAN && !this.noPan) {
        this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));
    }
}
function onMouseUp() {
    this.state = _STATE.NONE;
    this.dispatchEvent(_endEvent);
}
function onMouseWheel(event) {
    if (this.enabled === false) return;
    if (this.noZoom === true) return;
    event.preventDefault();
    switch(event.deltaMode){
        case 2:
            // Zoom in pages
            this._zoomStart.y -= event.deltaY * 0.025;
            break;
        case 1:
            // Zoom in lines
            this._zoomStart.y -= event.deltaY * 0.01;
            break;
        default:
            // undefined, 0, assume pixels
            this._zoomStart.y -= event.deltaY * 0.00025;
            break;
    }
    this.dispatchEvent(_startEvent);
    this.dispatchEvent(_endEvent);
}
function onContextMenu(event) {
    if (this.enabled === false) return;
    event.preventDefault();
}
function onTouchStart(event) {
    this._trackPointer(event);
    switch(this._pointers.length){
        case 1:
            this.state = _STATE.TOUCH_ROTATE;
            this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY));
            this._movePrev.copy(this._moveCurr);
            break;
        default:
            this.state = _STATE.TOUCH_ZOOM_PAN;
            const dx = this._pointers[0].pageX - this._pointers[1].pageX;
            const dy = this._pointers[0].pageY - this._pointers[1].pageY;
            this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            const x = (this._pointers[0].pageX + this._pointers[1].pageX) / 2;
            const y = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
            this._panStart.copy(this._getMouseOnScreen(x, y));
            this._panEnd.copy(this._panStart);
            break;
    }
    this.dispatchEvent(_startEvent);
}
function onTouchMove(event) {
    this._trackPointer(event);
    switch(this._pointers.length){
        case 1:
            this._movePrev.copy(this._moveCurr);
            this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
            break;
        default:
            const position = this._getSecondPointerPosition(event);
            const dx = event.pageX - position.x;
            const dy = event.pageY - position.y;
            this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            const x = (event.pageX + position.x) / 2;
            const y = (event.pageY + position.y) / 2;
            this._panEnd.copy(this._getMouseOnScreen(x, y));
            break;
    }
}
function onTouchEnd(event) {
    switch(this._pointers.length){
        case 0:
            this.state = _STATE.NONE;
            break;
        case 1:
            this.state = _STATE.TOUCH_ROTATE;
            this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));
            this._movePrev.copy(this._moveCurr);
            break;
        case 2:
            this.state = _STATE.TOUCH_ZOOM_PAN;
            for(let i = 0; i < this._pointers.length; i++){
                if (this._pointers[i].pointerId !== event.pointerId) {
                    const position = this._pointerPositions[this._pointers[i].pointerId];
                    this._moveCurr.copy(this._getMouseOnCircle(position.x, position.y));
                    this._movePrev.copy(this._moveCurr);
                    break;
                }
            }
            break;
    }
    this.dispatchEvent(_endEvent);
}
;
}),
"[project]/node_modules/three/examples/jsm/controls/OrbitControls.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OrbitControls",
    ()=>OrbitControls
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
/**
 * Fires when the camera has been transformed by the controls.
 *
 * @event OrbitControls#change
 * @type {Object}
 */ const _changeEvent = {
    type: 'change'
};
/**
 * Fires when an interaction was initiated.
 *
 * @event OrbitControls#start
 * @type {Object}
 */ const _startEvent = {
    type: 'start'
};
/**
 * Fires when an interaction has finished.
 *
 * @event OrbitControls#end
 * @type {Object}
 */ const _endEvent = {
    type: 'end'
};
const _ray = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ray"]();
const _plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
const _TILT_LIMIT = Math.cos(70 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].DEG2RAD);
const _v = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _twoPI = 2 * Math.PI;
const _STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
};
const _EPS = 0.000001;
/**
 * Orbit controls allow the camera to orbit around a target.
 *
 * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},
 * it maintains the "up" direction `object.up` (+Y by default).
 *
 * - Orbit: Left mouse / touch: one-finger move.
 * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
 * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.
 *
 * ```js
 * const controls = new OrbitControls( camera, renderer.domElement );
 *
 * // controls.update() must be called after any manual changes to the camera's transform
 * camera.position.set( 0, 20, 100 );
 * controls.update();
 *
 * function animate() {
 *
 * 	// required if controls.enableDamping or controls.autoRotate are set to true
 * 	controls.update();
 *
 * 	renderer.render( scene, camera );
 *
 * }
 * ```
 *
 * @augments Controls
 * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 */ class OrbitControls extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Controls"] {
    /**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	 */ constructor(object, domElement = null){
        super(object, domElement);
        this.state = _STATE.NONE;
        /**
		 * The focus point of the controls, the `object` orbits around this.
		 * It can be updated manually at any point to change the focus of the controls.
		 *
		 * @type {Vector3}
		 */ this.target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        /**
		 * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
		 * It can be updated manually at any point to change the center of interest
		 * for the `target`.
		 *
		 * @type {Vector3}
		 */ this.cursor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        /**
		 * How far you can dolly in (perspective camera only).
		 *
		 * @type {number}
		 * @default 0
		 */ this.minDistance = 0;
        /**
		 * How far you can dolly out (perspective camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */ this.maxDistance = Infinity;
        /**
		 * How far you can zoom in (orthographic camera only).
		 *
		 * @type {number}
		 * @default 0
		 */ this.minZoom = 0;
        /**
		 * How far you can zoom out (orthographic camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */ this.maxZoom = Infinity;
        /**
		 * How close you can get the target to the 3D `cursor`.
		 *
		 * @type {number}
		 * @default 0
		 */ this.minTargetRadius = 0;
        /**
		 * How far you can move the target from the 3D `cursor`.
		 *
		 * @type {number}
		 * @default Infinity
		 */ this.maxTargetRadius = Infinity;
        /**
		 * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.
		 *
		 * @type {number}
		 * @default 0
		 */ this.minPolarAngle = 0;
        /**
		 * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.
		 *
		 * @type {number}
		 * @default Math.PI
		 */ this.maxPolarAngle = Math.PI;
        /**
		 * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
		 *
		 * @type {number}
		 * @default -Infinity
		 */ this.minAzimuthAngle = -Infinity;
        /**
		 * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
		 *
		 * @type {number}
		 * @default -Infinity
		 */ this.maxAzimuthAngle = Infinity;
        /**
		 * Set to `true` to enable damping (inertia), which can be used to give a sense of weight
		 * to the controls. Note that if this is enabled, you must call `update()` in your animation
		 * loop.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.enableDamping = false;
        /**
		 * The damping inertia used if `enableDamping` is set to `true`.
		 *
		 * Note that for this to work, you must call `update()` in your animation loop.
		 *
		 * @type {number}
		 * @default 0.05
		 */ this.dampingFactor = 0.05;
        /**
		 * Enable or disable zooming (dollying) of the camera.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.enableZoom = true;
        /**
		 * Speed of zooming / dollying.
		 *
		 * @type {number}
		 * @default 1
		 */ this.zoomSpeed = 1.0;
        /**
		 * Enable or disable horizontal and vertical rotation of the camera.
		 *
		 * Note that it is possible to disable a single axis by setting the min and max of the
		 * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
		 * or horizontal rotation to be fixed at that value.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.enableRotate = true;
        /**
		 * Speed of rotation.
		 *
		 * @type {number}
		 * @default 1
		 */ this.rotateSpeed = 1.0;
        /**
		 * How fast to rotate the camera when the keyboard is used.
		 *
		 * @type {number}
		 * @default 1
		 */ this.keyRotateSpeed = 1.0;
        /**
		 * Enable or disable camera panning.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.enablePan = true;
        /**
		 * Speed of panning.
		 *
		 * @type {number}
		 * @default 1
		 */ this.panSpeed = 1.0;
        /**
		 * Defines how the camera's position is translated when panning. If `true`, the camera pans
		 * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
		 * direction.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.screenSpacePanning = true;
        /**
		 * How fast to pan the camera when the keyboard is used in
		 * pixels per keypress.
		 *
		 * @type {number}
		 * @default 7
		 */ this.keyPanSpeed = 7.0;
        /**
		 * Setting this property to `true` allows to zoom to the cursor's position.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.zoomToCursor = false;
        /**
		 * Set to true to automatically rotate around the target
		 *
		 * Note that if this is enabled, you must call `update()` in your animation loop.
		 * If you want the auto-rotate speed to be independent of the frame rate (the refresh
		 * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.autoRotate = false;
        /**
		 * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
		 * per orbit at 60fps.
		 *
		 * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.
		 *
		 * @type {number}
		 * @default 2
		 */ this.autoRotateSpeed = 2.0;
        /**
		 * This object contains references to the keycodes for controlling camera panning.
		 *
		 * ```js
		 * controls.keys = {
		 * 	LEFT: 'ArrowLeft', //left arrow
		 * 	UP: 'ArrowUp', // up arrow
		 * 	RIGHT: 'ArrowRight', // right arrow
		 * 	BOTTOM: 'ArrowDown' // down arrow
		 * }
		 * ```
		 * @type {Object}
		 */ this.keys = {
            LEFT: 'ArrowLeft',
            UP: 'ArrowUp',
            RIGHT: 'ArrowRight',
            BOTTOM: 'ArrowDown'
        };
        /**
		 * This object contains references to the mouse actions used by the controls.
		 *
		 * ```js
		 * controls.mouseButtons = {
		 * 	LEFT: THREE.MOUSE.ROTATE,
		 * 	MIDDLE: THREE.MOUSE.DOLLY,
		 * 	RIGHT: THREE.MOUSE.PAN
		 * }
		 * ```
		 * @type {Object}
		 */ this.mouseButtons = {
            LEFT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE,
            MIDDLE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].DOLLY,
            RIGHT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN
        };
        /**
		 * This object contains references to the touch actions used by the controls.
		 *
		 * ```js
		 * controls.mouseButtons = {
		 * 	ONE: THREE.TOUCH.ROTATE,
		 * 	TWO: THREE.TOUCH.DOLLY_PAN
		 * }
		 * ```
		 * @type {Object}
		 */ this.touches = {
            ONE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].ROTATE,
            TWO: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].DOLLY_PAN
        };
        /**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {Vector3}
		 */ this.target0 = this.target.clone();
        /**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {Vector3}
		 */ this.position0 = this.object.position.clone();
        /**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {number}
		 */ this.zoom0 = this.object.zoom;
        // the target DOM element for key events
        this._domElementKeyEvents = null;
        // internals
        this._lastPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lastQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        this._lastTargetPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        // so camera.up is the orbit axis
        this._quat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]().setFromUnitVectors(object.up, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0));
        this._quatInverse = this._quat.clone().invert();
        // current position in spherical coordinates
        this._spherical = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]();
        this._sphericalDelta = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]();
        this._scale = 1;
        this._panOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._rotateStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._rotateEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._rotateDelta = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._panStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._panEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._panDelta = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._dollyStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._dollyEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._dollyDelta = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._dollyDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._mouse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this._performCursorZoom = false;
        this._pointers = [];
        this._pointerPositions = {};
        this._controlActive = false;
        // event listeners
        this._onPointerMove = onPointerMove.bind(this);
        this._onPointerDown = onPointerDown.bind(this);
        this._onPointerUp = onPointerUp.bind(this);
        this._onContextMenu = onContextMenu.bind(this);
        this._onMouseWheel = onMouseWheel.bind(this);
        this._onKeyDown = onKeyDown.bind(this);
        this._onTouchStart = onTouchStart.bind(this);
        this._onTouchMove = onTouchMove.bind(this);
        this._onMouseDown = onMouseDown.bind(this);
        this._onMouseMove = onMouseMove.bind(this);
        this._interceptControlDown = interceptControlDown.bind(this);
        this._interceptControlUp = interceptControlUp.bind(this);
        //
        if (this.domElement !== null) {
            this.connect(this.domElement);
        }
        this.update();
    }
    connect(element) {
        super.connect(element);
        this.domElement.addEventListener('pointerdown', this._onPointerDown);
        this.domElement.addEventListener('pointercancel', this._onPointerUp);
        this.domElement.addEventListener('contextmenu', this._onContextMenu);
        this.domElement.addEventListener('wheel', this._onMouseWheel, {
            passive: false
        });
        const document = this.domElement.getRootNode(); // offscreen canvas compatibility
        document.addEventListener('keydown', this._interceptControlDown, {
            passive: true,
            capture: true
        });
        this.domElement.style.touchAction = 'none'; // disable touch scroll
    }
    disconnect() {
        this.domElement.removeEventListener('pointerdown', this._onPointerDown);
        this.domElement.ownerDocument.removeEventListener('pointermove', this._onPointerMove);
        this.domElement.ownerDocument.removeEventListener('pointerup', this._onPointerUp);
        this.domElement.removeEventListener('pointercancel', this._onPointerUp);
        this.domElement.removeEventListener('wheel', this._onMouseWheel);
        this.domElement.removeEventListener('contextmenu', this._onContextMenu);
        this.stopListenToKeyEvents();
        const document = this.domElement.getRootNode(); // offscreen canvas compatibility
        document.removeEventListener('keydown', this._interceptControlDown, {
            capture: true
        });
        this.domElement.style.touchAction = 'auto';
    }
    dispose() {
        this.disconnect();
    }
    /**
	 * Get the current vertical rotation, in radians.
	 *
	 * @return {number} The current vertical rotation, in radians.
	 */ getPolarAngle() {
        return this._spherical.phi;
    }
    /**
	 * Get the current horizontal rotation, in radians.
	 *
	 * @return {number} The current horizontal rotation, in radians.
	 */ getAzimuthalAngle() {
        return this._spherical.theta;
    }
    /**
	 * Returns the distance from the camera to the target.
	 *
	 * @return {number} The distance from the camera to the target.
	 */ getDistance() {
        return this.object.position.distanceTo(this.target);
    }
    /**
	 * Adds key event listeners to the given DOM element.
	 * `window` is a recommended argument for using this method.
	 *
	 * @param {HTMLElement} domElement - The DOM element
	 */ listenToKeyEvents(domElement) {
        domElement.addEventListener('keydown', this._onKeyDown);
        this._domElementKeyEvents = domElement;
    }
    /**
	 * Removes the key event listener previously defined with `listenToKeyEvents()`.
	 */ stopListenToKeyEvents() {
        if (this._domElementKeyEvents !== null) {
            this._domElementKeyEvents.removeEventListener('keydown', this._onKeyDown);
            this._domElementKeyEvents = null;
        }
    }
    /**
	 * Save the current state of the controls. This can later be recovered with `reset()`.
	 */ saveState() {
        this.target0.copy(this.target);
        this.position0.copy(this.object.position);
        this.zoom0 = this.object.zoom;
    }
    /**
	 * Reset the controls to their state from either the last time the `saveState()`
	 * was called, or the initial state.
	 */ reset() {
        this.target.copy(this.target0);
        this.object.position.copy(this.position0);
        this.object.zoom = this.zoom0;
        this.object.updateProjectionMatrix();
        this.dispatchEvent(_changeEvent);
        this.update();
        this.state = _STATE.NONE;
    }
    update(deltaTime = null) {
        const position = this.object.position;
        _v.copy(position).sub(this.target);
        // rotate offset to "y-axis-is-up" space
        _v.applyQuaternion(this._quat);
        // angle from z-axis around y-axis
        this._spherical.setFromVector3(_v);
        if (this.autoRotate && this.state === _STATE.NONE) {
            this._rotateLeft(this._getAutoRotationAngle(deltaTime));
        }
        if (this.enableDamping) {
            this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
            this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
        } else {
            this._spherical.theta += this._sphericalDelta.theta;
            this._spherical.phi += this._sphericalDelta.phi;
        }
        // restrict theta to be between desired limits
        let min = this.minAzimuthAngle;
        let max = this.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI) min += _twoPI;
            else if (min > Math.PI) min -= _twoPI;
            if (max < -Math.PI) max += _twoPI;
            else if (max > Math.PI) max -= _twoPI;
            if (min <= max) {
                this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
            } else {
                this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
            }
        }
        // restrict phi to be between desired limits
        this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
        this._spherical.makeSafe();
        // move target to panned location
        if (this.enableDamping === true) {
            this.target.addScaledVector(this._panOffset, this.dampingFactor);
        } else {
            this.target.add(this._panOffset);
        }
        // Limit the target distance from the cursor to create a sphere around the center of interest
        this.target.sub(this.cursor);
        this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
        this.target.add(this.cursor);
        let zoomChanged = false;
        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
        // we adjust zoom later in these cases
        if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
            this._spherical.radius = this._clampDistance(this._spherical.radius);
        } else {
            const prevRadius = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
            zoomChanged = prevRadius != this._spherical.radius;
        }
        _v.setFromSpherical(this._spherical);
        // rotate offset back to "camera-up-vector-is-up" space
        _v.applyQuaternion(this._quatInverse);
        position.copy(this.target).add(_v);
        this.object.lookAt(this.target);
        if (this.enableDamping === true) {
            this._sphericalDelta.theta *= 1 - this.dampingFactor;
            this._sphericalDelta.phi *= 1 - this.dampingFactor;
            this._panOffset.multiplyScalar(1 - this.dampingFactor);
        } else {
            this._sphericalDelta.set(0, 0, 0);
            this._panOffset.set(0, 0, 0);
        }
        // adjust camera position
        if (this.zoomToCursor && this._performCursorZoom) {
            let newRadius = null;
            if (this.object.isPerspectiveCamera) {
                // move the camera down the pointer ray
                // this method avoids floating point error
                const prevRadius = _v.length();
                newRadius = this._clampDistance(prevRadius * this._scale);
                const radiusDelta = prevRadius - newRadius;
                this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
                this.object.updateMatrixWorld();
                zoomChanged = !!radiusDelta;
            } else if (this.object.isOrthographicCamera) {
                // adjust the ortho camera position based on zoom changes
                const mouseBefore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](this._mouse.x, this._mouse.y, 0);
                mouseBefore.unproject(this.object);
                const prevZoom = this.object.zoom;
                this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
                this.object.updateProjectionMatrix();
                zoomChanged = prevZoom !== this.object.zoom;
                const mouseAfter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](this._mouse.x, this._mouse.y, 0);
                mouseAfter.unproject(this.object);
                this.object.position.sub(mouseAfter).add(mouseBefore);
                this.object.updateMatrixWorld();
                newRadius = _v.length();
            } else {
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.');
                this.zoomToCursor = false;
            }
            // handle the placement of the target
            if (newRadius !== null) {
                if (this.screenSpacePanning) {
                    // position the orbit target in front of the new camera position
                    this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
                } else {
                    // get the ray and translation plane to compute target
                    _ray.origin.copy(this.object.position);
                    _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
                    // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
                    // extremely large values
                    if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
                        this.object.lookAt(this.target);
                    } else {
                        _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
                        _ray.intersectPlane(_plane, this.target);
                    }
                }
            }
        } else if (this.object.isOrthographicCamera) {
            const prevZoom = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
            if (prevZoom !== this.object.zoom) {
                this.object.updateProjectionMatrix();
                zoomChanged = true;
            }
        }
        this._scale = 1;
        this._performCursorZoom = false;
        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8
        if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
            this.dispatchEvent(_changeEvent);
            this._lastPosition.copy(this.object.position);
            this._lastQuaternion.copy(this.object.quaternion);
            this._lastTargetPosition.copy(this.target);
            return true;
        }
        return false;
    }
    _getAutoRotationAngle(deltaTime) {
        if (deltaTime !== null) {
            return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
        } else {
            return _twoPI / 60 / 60 * this.autoRotateSpeed;
        }
    }
    _getZoomScale(delta) {
        const normalizedDelta = Math.abs(delta * 0.01);
        return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
    }
    _rotateLeft(angle) {
        this._sphericalDelta.theta -= angle;
    }
    _rotateUp(angle) {
        this._sphericalDelta.phi -= angle;
    }
    _panLeft(distance, objectMatrix) {
        _v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
        _v.multiplyScalar(-distance);
        this._panOffset.add(_v);
    }
    _panUp(distance, objectMatrix) {
        if (this.screenSpacePanning === true) {
            _v.setFromMatrixColumn(objectMatrix, 1);
        } else {
            _v.setFromMatrixColumn(objectMatrix, 0);
            _v.crossVectors(this.object.up, _v);
        }
        _v.multiplyScalar(distance);
        this._panOffset.add(_v);
    }
    // deltaX and deltaY are in pixels; right and down are positive
    _pan(deltaX, deltaY) {
        const element = this.domElement;
        if (this.object.isPerspectiveCamera) {
            // perspective
            const position = this.object.position;
            _v.copy(position).sub(this.target);
            let targetDistance = _v.length();
            // half of the fov is center to top of screen
            targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
            this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
        } else if (this.object.isOrthographicCamera) {
            // orthographic
            this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);
            this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);
        } else {
            // camera neither orthographic nor perspective
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
            this.enablePan = false;
        }
    }
    _dollyOut(dollyScale) {
        if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
            this._scale /= dollyScale;
        } else {
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            this.enableZoom = false;
        }
    }
    _dollyIn(dollyScale) {
        if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
            this._scale *= dollyScale;
        } else {
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            this.enableZoom = false;
        }
    }
    _updateZoomParameters(x, y) {
        if (!this.zoomToCursor) {
            return;
        }
        this._performCursorZoom = true;
        const rect = this.domElement.getBoundingClientRect();
        const dx = x - rect.left;
        const dy = y - rect.top;
        const w = rect.width;
        const h = rect.height;
        this._mouse.x = dx / w * 2 - 1;
        this._mouse.y = -(dy / h) * 2 + 1;
        this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
    }
    _clampDistance(dist) {
        return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
    }
    //
    // event callbacks - update the object state
    //
    _handleMouseDownRotate(event) {
        this._rotateStart.set(event.clientX, event.clientY);
    }
    _handleMouseDownDolly(event) {
        this._updateZoomParameters(event.clientX, event.clientX);
        this._dollyStart.set(event.clientX, event.clientY);
    }
    _handleMouseDownPan(event) {
        this._panStart.set(event.clientX, event.clientY);
    }
    _handleMouseMoveRotate(event) {
        this._rotateEnd.set(event.clientX, event.clientY);
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const element = this.domElement;
        this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height
        this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
        this._rotateStart.copy(this._rotateEnd);
        this.update();
    }
    _handleMouseMoveDolly(event) {
        this._dollyEnd.set(event.clientX, event.clientY);
        this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
        if (this._dollyDelta.y > 0) {
            this._dollyOut(this._getZoomScale(this._dollyDelta.y));
        } else if (this._dollyDelta.y < 0) {
            this._dollyIn(this._getZoomScale(this._dollyDelta.y));
        }
        this._dollyStart.copy(this._dollyEnd);
        this.update();
    }
    _handleMouseMovePan(event) {
        this._panEnd.set(event.clientX, event.clientY);
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
        this._pan(this._panDelta.x, this._panDelta.y);
        this._panStart.copy(this._panEnd);
        this.update();
    }
    _handleMouseWheel(event) {
        this._updateZoomParameters(event.clientX, event.clientY);
        if (event.deltaY < 0) {
            this._dollyIn(this._getZoomScale(event.deltaY));
        } else if (event.deltaY > 0) {
            this._dollyOut(this._getZoomScale(event.deltaY));
        }
        this.update();
    }
    _handleKeyDown(event) {
        let needsUpdate = false;
        switch(event.code){
            case this.keys.UP:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (this.enableRotate) {
                        this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
                    }
                } else {
                    if (this.enablePan) {
                        this._pan(0, this.keyPanSpeed);
                    }
                }
                needsUpdate = true;
                break;
            case this.keys.BOTTOM:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (this.enableRotate) {
                        this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
                    }
                } else {
                    if (this.enablePan) {
                        this._pan(0, -this.keyPanSpeed);
                    }
                }
                needsUpdate = true;
                break;
            case this.keys.LEFT:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (this.enableRotate) {
                        this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
                    }
                } else {
                    if (this.enablePan) {
                        this._pan(this.keyPanSpeed, 0);
                    }
                }
                needsUpdate = true;
                break;
            case this.keys.RIGHT:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (this.enableRotate) {
                        this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
                    }
                } else {
                    if (this.enablePan) {
                        this._pan(-this.keyPanSpeed, 0);
                    }
                }
                needsUpdate = true;
                break;
        }
        if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();
            this.update();
        }
    }
    _handleTouchStartRotate(event) {
        if (this._pointers.length === 1) {
            this._rotateStart.set(event.pageX, event.pageY);
        } else {
            const position = this._getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            this._rotateStart.set(x, y);
        }
    }
    _handleTouchStartPan(event) {
        if (this._pointers.length === 1) {
            this._panStart.set(event.pageX, event.pageY);
        } else {
            const position = this._getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            this._panStart.set(x, y);
        }
    }
    _handleTouchStartDolly(event) {
        const position = this._getSecondPointerPosition(event);
        const dx = event.pageX - position.x;
        const dy = event.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this._dollyStart.set(0, distance);
    }
    _handleTouchStartDollyPan(event) {
        if (this.enableZoom) this._handleTouchStartDolly(event);
        if (this.enablePan) this._handleTouchStartPan(event);
    }
    _handleTouchStartDollyRotate(event) {
        if (this.enableZoom) this._handleTouchStartDolly(event);
        if (this.enableRotate) this._handleTouchStartRotate(event);
    }
    _handleTouchMoveRotate(event) {
        if (this._pointers.length == 1) {
            this._rotateEnd.set(event.pageX, event.pageY);
        } else {
            const position = this._getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            this._rotateEnd.set(x, y);
        }
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const element = this.domElement;
        this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight); // yes, height
        this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
        this._rotateStart.copy(this._rotateEnd);
    }
    _handleTouchMovePan(event) {
        if (this._pointers.length === 1) {
            this._panEnd.set(event.pageX, event.pageY);
        } else {
            const position = this._getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            this._panEnd.set(x, y);
        }
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
        this._pan(this._panDelta.x, this._panDelta.y);
        this._panStart.copy(this._panEnd);
    }
    _handleTouchMoveDolly(event) {
        const position = this._getSecondPointerPosition(event);
        const dx = event.pageX - position.x;
        const dy = event.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this._dollyEnd.set(0, distance);
        this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
        this._dollyOut(this._dollyDelta.y);
        this._dollyStart.copy(this._dollyEnd);
        const centerX = (event.pageX + position.x) * 0.5;
        const centerY = (event.pageY + position.y) * 0.5;
        this._updateZoomParameters(centerX, centerY);
    }
    _handleTouchMoveDollyPan(event) {
        if (this.enableZoom) this._handleTouchMoveDolly(event);
        if (this.enablePan) this._handleTouchMovePan(event);
    }
    _handleTouchMoveDollyRotate(event) {
        if (this.enableZoom) this._handleTouchMoveDolly(event);
        if (this.enableRotate) this._handleTouchMoveRotate(event);
    }
    // pointers
    _addPointer(event) {
        this._pointers.push(event.pointerId);
    }
    _removePointer(event) {
        delete this._pointerPositions[event.pointerId];
        for(let i = 0; i < this._pointers.length; i++){
            if (this._pointers[i] == event.pointerId) {
                this._pointers.splice(i, 1);
                return;
            }
        }
    }
    _isTrackingPointer(event) {
        for(let i = 0; i < this._pointers.length; i++){
            if (this._pointers[i] == event.pointerId) return true;
        }
        return false;
    }
    _trackPointer(event) {
        let position = this._pointerPositions[event.pointerId];
        if (position === undefined) {
            position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
            this._pointerPositions[event.pointerId] = position;
        }
        position.set(event.pageX, event.pageY);
    }
    _getSecondPointerPosition(event) {
        const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
        return this._pointerPositions[pointerId];
    }
    //
    _customWheelEvent(event) {
        const mode = event.deltaMode;
        // minimal wheel event altered to meet delta-zoom demand
        const newEvent = {
            clientX: event.clientX,
            clientY: event.clientY,
            deltaY: event.deltaY
        };
        switch(mode){
            case 1:
                newEvent.deltaY *= 16;
                break;
            case 2:
                newEvent.deltaY *= 100;
                break;
        }
        // detect if event was triggered by pinching
        if (event.ctrlKey && !this._controlActive) {
            newEvent.deltaY *= 10;
        }
        return newEvent;
    }
}
function onPointerDown(event) {
    if (this.enabled === false) return;
    if (this._pointers.length === 0) {
        this.domElement.setPointerCapture(event.pointerId);
        this.domElement.ownerDocument.addEventListener('pointermove', this._onPointerMove);
        this.domElement.ownerDocument.addEventListener('pointerup', this._onPointerUp);
    }
    //
    if (this._isTrackingPointer(event)) return;
    //
    this._addPointer(event);
    if (event.pointerType === 'touch') {
        this._onTouchStart(event);
    } else {
        this._onMouseDown(event);
    }
}
function onPointerMove(event) {
    if (this.enabled === false) return;
    if (event.pointerType === 'touch') {
        this._onTouchMove(event);
    } else {
        this._onMouseMove(event);
    }
}
function onPointerUp(event) {
    this._removePointer(event);
    switch(this._pointers.length){
        case 0:
            this.domElement.releasePointerCapture(event.pointerId);
            this.domElement.ownerDocument.removeEventListener('pointermove', this._onPointerMove);
            this.domElement.ownerDocument.removeEventListener('pointerup', this._onPointerUp);
            this.dispatchEvent(_endEvent);
            this.state = _STATE.NONE;
            break;
        case 1:
            const pointerId = this._pointers[0];
            const position = this._pointerPositions[pointerId];
            // minimal placeholder event - allows state correction on pointer-up
            this._onTouchStart({
                pointerId: pointerId,
                pageX: position.x,
                pageY: position.y
            });
            break;
    }
}
function onMouseDown(event) {
    let mouseAction;
    switch(event.button){
        case 0:
            mouseAction = this.mouseButtons.LEFT;
            break;
        case 1:
            mouseAction = this.mouseButtons.MIDDLE;
            break;
        case 2:
            mouseAction = this.mouseButtons.RIGHT;
            break;
        default:
            mouseAction = -1;
    }
    switch(mouseAction){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(event);
            this.state = _STATE.DOLLY;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (this.enablePan === false) return;
                this._handleMouseDownPan(event);
                this.state = _STATE.PAN;
            } else {
                if (this.enableRotate === false) return;
                this._handleMouseDownRotate(event);
                this.state = _STATE.ROTATE;
            }
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MOUSE"].PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (this.enableRotate === false) return;
                this._handleMouseDownRotate(event);
                this.state = _STATE.ROTATE;
            } else {
                if (this.enablePan === false) return;
                this._handleMouseDownPan(event);
                this.state = _STATE.PAN;
            }
            break;
        default:
            this.state = _STATE.NONE;
    }
    if (this.state !== _STATE.NONE) {
        this.dispatchEvent(_startEvent);
    }
}
function onMouseMove(event) {
    switch(this.state){
        case _STATE.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(event);
            break;
        case _STATE.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(event);
            break;
        case _STATE.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(event);
            break;
    }
}
function onMouseWheel(event) {
    if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
    event.preventDefault();
    this.dispatchEvent(_startEvent);
    this._handleMouseWheel(this._customWheelEvent(event));
    this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
    if (this.enabled === false) return;
    this._handleKeyDown(event);
}
function onTouchStart(event) {
    this._trackPointer(event);
    switch(this._pointers.length){
        case 1:
            switch(this.touches.ONE){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].ROTATE:
                    if (this.enableRotate === false) return;
                    this._handleTouchStartRotate(event);
                    this.state = _STATE.TOUCH_ROTATE;
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].PAN:
                    if (this.enablePan === false) return;
                    this._handleTouchStartPan(event);
                    this.state = _STATE.TOUCH_PAN;
                    break;
                default:
                    this.state = _STATE.NONE;
            }
            break;
        case 2:
            switch(this.touches.TWO){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].DOLLY_PAN:
                    if (this.enableZoom === false && this.enablePan === false) return;
                    this._handleTouchStartDollyPan(event);
                    this.state = _STATE.TOUCH_DOLLY_PAN;
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TOUCH"].DOLLY_ROTATE:
                    if (this.enableZoom === false && this.enableRotate === false) return;
                    this._handleTouchStartDollyRotate(event);
                    this.state = _STATE.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    this.state = _STATE.NONE;
            }
            break;
        default:
            this.state = _STATE.NONE;
    }
    if (this.state !== _STATE.NONE) {
        this.dispatchEvent(_startEvent);
    }
}
function onTouchMove(event) {
    this._trackPointer(event);
    switch(this.state){
        case _STATE.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(event);
            this.update();
            break;
        case _STATE.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(event);
            this.update();
            break;
        case _STATE.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(event);
            this.update();
            break;
        case _STATE.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(event);
            this.update();
            break;
        default:
            this.state = _STATE.NONE;
    }
}
function onContextMenu(event) {
    if (this.enabled === false) return;
    event.preventDefault();
}
function interceptControlDown(event) {
    if (event.key === 'Control') {
        this._controlActive = true;
        const document = this.domElement.getRootNode(); // offscreen canvas compatibility
        document.addEventListener('keyup', this._interceptControlUp, {
            passive: true,
            capture: true
        });
    }
}
function interceptControlUp(event) {
    if (event.key === 'Control') {
        this._controlActive = false;
        const document = this.domElement.getRootNode(); // offscreen canvas compatibility
        document.removeEventListener('keyup', this._interceptControlUp, {
            passive: true,
            capture: true
        });
    }
}
;
}),
"[project]/node_modules/three/examples/jsm/controls/FlyControls.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FlyControls",
    ()=>FlyControls
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
/**
 * Fires when the camera has been transformed by the controls.
 *
 * @event FlyControls#change
 * @type {Object}
 */ const _changeEvent = {
    type: 'change'
};
const _EPS = 0.000001;
const _tmpQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
/**
 * This class enables a navigation similar to fly modes in DCC tools like Blender.
 * You can arbitrarily transform the camera in 3D space without any limitations
 * (e.g. focus on a specific target).
 *
 * @augments Controls
 * @three_import import { FlyControls } from 'three/addons/controls/FlyControls.js';
 */ class FlyControls extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Controls"] {
    /**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	 */ constructor(object, domElement = null){
        super(object, domElement);
        /**
		 * The movement speed.
		 *
		 * @type {number}
		 * @default 1
		 */ this.movementSpeed = 1.0;
        /**
		 * The rotation speed.
		 *
		 * @type {number}
		 * @default 0.005
		 */ this.rollSpeed = 0.005;
        /**
		 * If set to `true`, you can only look around by performing a drag interaction.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.dragToLook = false;
        /**
		 * If set to `true`, the camera automatically moves forward (and does not stop) when initially translated.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.autoForward = false;
        // internals
        this._moveState = {
            up: 0,
            down: 0,
            left: 0,
            right: 0,
            forward: 0,
            back: 0,
            pitchUp: 0,
            pitchDown: 0,
            yawLeft: 0,
            yawRight: 0,
            rollLeft: 0,
            rollRight: 0
        };
        this._moveVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
        this._rotationVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
        this._lastQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        this._lastPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._status = 0;
        // event listeners
        this._onKeyDown = onKeyDown.bind(this);
        this._onKeyUp = onKeyUp.bind(this);
        this._onPointerMove = onPointerMove.bind(this);
        this._onPointerDown = onPointerDown.bind(this);
        this._onPointerUp = onPointerUp.bind(this);
        this._onPointerCancel = onPointerCancel.bind(this);
        this._onContextMenu = onContextMenu.bind(this);
        //
        if (domElement !== null) {
            this.connect(domElement);
        }
    }
    connect(element) {
        super.connect(element);
        window.addEventListener('keydown', this._onKeyDown);
        window.addEventListener('keyup', this._onKeyUp);
        this.domElement.addEventListener('pointermove', this._onPointerMove);
        this.domElement.addEventListener('pointerdown', this._onPointerDown);
        this.domElement.addEventListener('pointerup', this._onPointerUp);
        this.domElement.addEventListener('pointercancel', this._onPointerCancel);
        this.domElement.addEventListener('contextmenu', this._onContextMenu);
    }
    disconnect() {
        window.removeEventListener('keydown', this._onKeyDown);
        window.removeEventListener('keyup', this._onKeyUp);
        this.domElement.removeEventListener('pointermove', this._onPointerMove);
        this.domElement.removeEventListener('pointerdown', this._onPointerDown);
        this.domElement.removeEventListener('pointerup', this._onPointerUp);
        this.domElement.removeEventListener('pointercancel', this._onPointerCancel);
        this.domElement.removeEventListener('contextmenu', this._onContextMenu);
    }
    dispose() {
        this.disconnect();
    }
    update(delta) {
        if (this.enabled === false) return;
        const object = this.object;
        const moveMult = delta * this.movementSpeed;
        const rotMult = delta * this.rollSpeed;
        object.translateX(this._moveVector.x * moveMult);
        object.translateY(this._moveVector.y * moveMult);
        object.translateZ(this._moveVector.z * moveMult);
        _tmpQuaternion.set(this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1).normalize();
        object.quaternion.multiply(_tmpQuaternion);
        if (this._lastPosition.distanceToSquared(object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(object.quaternion)) > _EPS) {
            this.dispatchEvent(_changeEvent);
            this._lastQuaternion.copy(object.quaternion);
            this._lastPosition.copy(object.position);
        }
    }
    // private
    _updateMovementVector() {
        const forward = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
        this._moveVector.x = -this._moveState.left + this._moveState.right;
        this._moveVector.y = -this._moveState.down + this._moveState.up;
        this._moveVector.z = -forward + this._moveState.back;
    //console.log( 'move:', [ this._moveVector.x, this._moveVector.y, this._moveVector.z ] );
    }
    _updateRotationVector() {
        this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp;
        this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft;
        this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
    //console.log( 'rotate:', [ this._rotationVector.x, this._rotationVector.y, this._rotationVector.z ] );
    }
    _getContainerDimensions() {
        if (this.domElement != document) {
            return {
                size: [
                    this.domElement.offsetWidth,
                    this.domElement.offsetHeight
                ],
                offset: [
                    this.domElement.offsetLeft,
                    this.domElement.offsetTop
                ]
            };
        } else {
            return {
                size: [
                    window.innerWidth,
                    window.innerHeight
                ],
                offset: [
                    0,
                    0
                ]
            };
        }
    }
}
function onKeyDown(event) {
    if (event.altKey || this.enabled === false) {
        return;
    }
    switch(event.code){
        case 'ShiftLeft':
        case 'ShiftRight':
            this.movementSpeedMultiplier = .1;
            break;
        case 'KeyW':
            this._moveState.forward = 1;
            break;
        case 'KeyS':
            this._moveState.back = 1;
            break;
        case 'KeyA':
            this._moveState.left = 1;
            break;
        case 'KeyD':
            this._moveState.right = 1;
            break;
        case 'KeyR':
            this._moveState.up = 1;
            break;
        case 'KeyF':
            this._moveState.down = 1;
            break;
        case 'ArrowUp':
            this._moveState.pitchUp = 1;
            break;
        case 'ArrowDown':
            this._moveState.pitchDown = 1;
            break;
        case 'ArrowLeft':
            this._moveState.yawLeft = 1;
            break;
        case 'ArrowRight':
            this._moveState.yawRight = 1;
            break;
        case 'KeyQ':
            this._moveState.rollLeft = 1;
            break;
        case 'KeyE':
            this._moveState.rollRight = 1;
            break;
    }
    this._updateMovementVector();
    this._updateRotationVector();
}
function onKeyUp(event) {
    if (this.enabled === false) return;
    switch(event.code){
        case 'ShiftLeft':
        case 'ShiftRight':
            this.movementSpeedMultiplier = 1;
            break;
        case 'KeyW':
            this._moveState.forward = 0;
            break;
        case 'KeyS':
            this._moveState.back = 0;
            break;
        case 'KeyA':
            this._moveState.left = 0;
            break;
        case 'KeyD':
            this._moveState.right = 0;
            break;
        case 'KeyR':
            this._moveState.up = 0;
            break;
        case 'KeyF':
            this._moveState.down = 0;
            break;
        case 'ArrowUp':
            this._moveState.pitchUp = 0;
            break;
        case 'ArrowDown':
            this._moveState.pitchDown = 0;
            break;
        case 'ArrowLeft':
            this._moveState.yawLeft = 0;
            break;
        case 'ArrowRight':
            this._moveState.yawRight = 0;
            break;
        case 'KeyQ':
            this._moveState.rollLeft = 0;
            break;
        case 'KeyE':
            this._moveState.rollRight = 0;
            break;
    }
    this._updateMovementVector();
    this._updateRotationVector();
}
function onPointerDown(event) {
    if (this.enabled === false) return;
    if (this.dragToLook) {
        this._status++;
    } else {
        switch(event.button){
            case 0:
                this._moveState.forward = 1;
                break;
            case 2:
                this._moveState.back = 1;
                break;
        }
        this._updateMovementVector();
    }
}
function onPointerMove(event) {
    if (this.enabled === false) return;
    if (!this.dragToLook || this._status > 0) {
        const container = this._getContainerDimensions();
        const halfWidth = container.size[0] / 2;
        const halfHeight = container.size[1] / 2;
        this._moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
        this._moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;
        this._updateRotationVector();
    }
}
function onPointerUp(event) {
    if (this.enabled === false) return;
    if (this.dragToLook) {
        this._status--;
        this._moveState.yawLeft = this._moveState.pitchDown = 0;
    } else {
        switch(event.button){
            case 0:
                this._moveState.forward = 0;
                break;
            case 2:
                this._moveState.back = 0;
                break;
        }
        this._updateMovementVector();
    }
    this._updateRotationVector();
}
function onPointerCancel() {
    if (this.enabled === false) return;
    if (this.dragToLook) {
        this._status = 0;
        this._moveState.yawLeft = this._moveState.pitchDown = 0;
    } else {
        this._moveState.forward = 0;
        this._moveState.back = 0;
        this._updateMovementVector();
    }
    this._updateRotationVector();
}
function onContextMenu(event) {
    if (this.enabled === false) return;
    event.preventDefault();
}
;
}),
"[project]/node_modules/three/examples/jsm/shaders/CopyShader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CopyShader",
    ()=>CopyShader
]);
/**
 * @module CopyShader
 * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';
 */ /**
 * Full-screen copy shader pass.
 *
 * @constant
 * @type {ShaderMaterial~Shader}
 */ const CopyShader = {
    name: 'CopyShader',
    uniforms: {
        'tDiffuse': {
            value: null
        },
        'opacity': {
            value: 1.0
        }
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
};
;
}),
"[project]/node_modules/three/examples/jsm/postprocessing/Pass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FullScreenQuad",
    ()=>FullScreenQuad,
    "Pass",
    ()=>Pass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
/**
 * Abstract base class for all post processing passes.
 *
 * This module is only relevant for post processing with {@link WebGLRenderer}.
 *
 * @abstract
 * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';
 */ class Pass {
    /**
	 * Constructs a new pass.
	 */ constructor(){
        /**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */ this.isPass = true;
        /**
		 * If set to `true`, the pass is processed by the composer.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.enabled = true;
        /**
		 * If set to `true`, the pass indicates to swap read and write buffer after rendering.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.needsSwap = true;
        /**
		 * If set to `true`, the pass clears its buffer before rendering
		 *
		 * @type {boolean}
		 * @default false
		 */ this.clear = false;
        /**
		 * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
		 * pass chain gets automatically rendered to screen, no matter how this property is configured.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.renderToScreen = false;
    }
    /**
	 * Sets the size of the pass.
	 *
	 * @abstract
	 * @param {number} width - The width to set.
	 * @param {number} height - The height to set.
	 */ setSize() {}
    /**
	 * This method holds the render logic of a pass. It must be implemented in all derived classes.
	 *
	 * @abstract
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */ render() {
        console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
    /**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the pass is no longer used in your app.
	 *
	 * @abstract
	 */ dispose() {}
}
// Helper for passes that need to fill the viewport with a single quad.
const _camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-1, 1, 1, -1, 0, 1);
// https://github.com/mrdoob/three.js/pull/21358
class FullscreenTriangleGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(){
        super();
        this.setAttribute('position', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"]([
            -1,
            3,
            0,
            -1,
            -1,
            0,
            3,
            -1,
            0
        ], 3));
        this.setAttribute('uv', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"]([
            0,
            2,
            0,
            0,
            2,
            0
        ], 2));
    }
}
const _geometry = new FullscreenTriangleGeometry();
/**
 * This module is a helper for passes which need to render a full
 * screen effect which is quite common in context of post processing.
 *
 * The intended usage is to reuse a single full screen quad for rendering
 * subsequent passes by just reassigning the `material` reference.
 *
 * This module can only be used with {@link WebGLRenderer}.
 *
 * @augments Mesh
 * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';
 */ class FullScreenQuad {
    /**
	 * Constructs a new full screen quad.
	 *
	 * @param {?Material} material - The material to render te full screen quad with.
	 */ constructor(material){
        this._mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](_geometry, material);
    }
    /**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the instance is no longer used in your app.
	 */ dispose() {
        this._mesh.geometry.dispose();
    }
    /**
	 * Renders the full screen quad.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 */ render(renderer) {
        renderer.render(this._mesh, _camera);
    }
    /**
	 * The quad's material.
	 *
	 * @type {?Material}
	 */ get material() {
        return this._mesh.material;
    }
    set material(value) {
        this._mesh.material = value;
    }
}
;
}),
"[project]/node_modules/three/examples/jsm/postprocessing/ShaderPass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShaderPass",
    ()=>ShaderPass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/postprocessing/Pass.js [app-client] (ecmascript)");
;
;
/**
 * This pass can be used to create a post processing effect
 * with a raw GLSL shader object. Useful for implementing custom
 * effects.
 *
 * ```js
 * const fxaaPass = new ShaderPass( FXAAShader );
 * composer.addPass( fxaaPass );
 * ```
 *
 * @augments Pass
 * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 */ class ShaderPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pass"] {
    /**
	 * Constructs a new shader pass.
	 *
	 * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
	 * defines and uniforms. It's also valid to pass a custom shader material.
	 * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
	 * the read buffer.
	 */ constructor(shader, textureID = 'tDiffuse'){
        super();
        /**
		 * The name of the texture uniform that should sample the read buffer.
		 *
		 * @type {string}
		 * @default 'tDiffuse'
		 */ this.textureID = textureID;
        /**
		 * The pass uniforms.
		 *
		 * @type {?Object}
		 */ this.uniforms = null;
        /**
		 * The pass material.
		 *
		 * @type {?ShaderMaterial}
		 */ this.material = null;
        if (shader instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        } else if (shader) {
            this.uniforms = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(shader.uniforms);
            this.material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                name: shader.name !== undefined ? shader.name : 'unspecified',
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        // internals
        this._fsQuad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FullScreenQuad"](this.material);
    }
    /**
	 * Performs the shader pass.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */ render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this._fsQuad.material = this.material;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            this._fsQuad.render(renderer);
        } else {
            renderer.setRenderTarget(writeBuffer);
            // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
            if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            this._fsQuad.render(renderer);
        }
    }
    /**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the pass is no longer used in your app.
	 */ dispose() {
        this.material.dispose();
        this._fsQuad.dispose();
    }
}
;
}),
"[project]/node_modules/three/examples/jsm/postprocessing/MaskPass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ClearMaskPass",
    ()=>ClearMaskPass,
    "MaskPass",
    ()=>MaskPass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/postprocessing/Pass.js [app-client] (ecmascript)");
;
/**
 * This pass can be used to define a mask during post processing.
 * Meaning only areas of subsequent post processing are affected
 * which lie in the masking area of this pass. Internally, the masking
 * is implemented with the stencil buffer.
 *
 * ```js
 * const maskPass = new MaskPass( scene, camera );
 * composer.addPass( maskPass );
 * ```
 *
 * @augments Pass
 * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';
 */ class MaskPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pass"] {
    /**
	 * Constructs a new mask pass.
	 *
	 * @param {Scene} scene - The 3D objects in this scene will define the mask.
	 * @param {Camera} camera - The camera.
	 */ constructor(scene, camera){
        super();
        /**
		 * The scene that defines the mask.
		 *
		 * @type {Scene}
		 */ this.scene = scene;
        /**
		 * The camera.
		 *
		 * @type {Camera}
		 */ this.camera = camera;
        /**
		 * Overwritten to perform a clear operation by default.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.clear = true;
        /**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.needsSwap = false;
        /**
		 * Whether to inverse the mask or not.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.inverse = false;
    }
    /**
	 * Performs a mask pass with the configured scene and camera.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */ render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        const context = renderer.getContext();
        const state = renderer.state;
        // don't update color or depth
        state.buffers.color.setMask(false);
        state.buffers.depth.setMask(false);
        // lock buffers
        state.buffers.color.setLocked(true);
        state.buffers.depth.setLocked(true);
        // set up stencil
        let writeValue, clearValue;
        if (this.inverse) {
            writeValue = 0;
            clearValue = 1;
        } else {
            writeValue = 1;
            clearValue = 0;
        }
        state.buffers.stencil.setTest(true);
        state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
        state.buffers.stencil.setClear(clearValue);
        state.buffers.stencil.setLocked(true);
        // draw into the stencil buffer
        renderer.setRenderTarget(readBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        // unlock color and depth buffer and make them writable for subsequent rendering/clearing
        state.buffers.color.setLocked(false);
        state.buffers.depth.setLocked(false);
        state.buffers.color.setMask(true);
        state.buffers.depth.setMask(true);
        // only render where stencil is set to 1
        state.buffers.stencil.setLocked(false);
        state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
        state.buffers.stencil.setLocked(true);
    }
}
/**
 * This pass can be used to clear a mask previously defined with {@link MaskPass}.
 *
 * ```js
 * const clearPass = new ClearMaskPass();
 * composer.addPass( clearPass );
 * ```
 *
 * @augments Pass
 */ class ClearMaskPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pass"] {
    /**
	 * Constructs a new clear mask pass.
	 */ constructor(){
        super();
        /**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.needsSwap = false;
    }
    /**
	 * Performs the clear of the currently defined mask.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */ render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {
        renderer.state.buffers.stencil.setLocked(false);
        renderer.state.buffers.stencil.setTest(false);
    }
}
;
}),
"[project]/node_modules/three/examples/jsm/postprocessing/EffectComposer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EffectComposer",
    ()=>EffectComposer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$CopyShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/shaders/CopyShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$ShaderPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/postprocessing/ShaderPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$MaskPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/postprocessing/MaskPass.js [app-client] (ecmascript)");
;
;
;
;
/**
 * Used to implement post-processing effects in three.js.
 * The class manages a chain of post-processing passes to produce the final visual result.
 * Post-processing passes are executed in order of their addition/insertion.
 * The last pass is automatically rendered to screen.
 *
 * This module can only be used with {@link WebGLRenderer}.
 *
 * ```js
 * const composer = new EffectComposer( renderer );
 *
 * // adding some passes
 * const renderPass = new RenderPass( scene, camera );
 * composer.addPass( renderPass );
 *
 * const glitchPass = new GlitchPass();
 * composer.addPass( glitchPass );
 *
 * const outputPass = new OutputPass()
 * composer.addPass( outputPass );
 *
 * function animate() {
 *
 * 	composer.render(); // instead of renderer.render()
 *
 * }
 * ```
 *
 * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 */ class EffectComposer {
    /**
	 * Constructs a new effect composer.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
	 * be used as the internal read and write buffers. If not given, the composer creates
	 * the buffers automatically.
	 */ constructor(renderer, renderTarget){
        /**
		 * The renderer.
		 *
		 * @type {WebGLRenderer}
		 */ this.renderer = renderer;
        this._pixelRatio = renderer.getPixelRatio();
        if (renderTarget === undefined) {
            const size = renderer.getSize(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]());
            this._width = size.width;
            this._height = size.height;
            renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](this._width * this._pixelRatio, this._height * this._pixelRatio, {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]
            });
            renderTarget.texture.name = 'EffectComposer.rt1';
        } else {
            this._width = renderTarget.width;
            this._height = renderTarget.height;
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.renderTarget2.texture.name = 'EffectComposer.rt2';
        /**
		 * A reference to the internal write buffer. Passes usually write
		 * their result into this buffer.
		 *
		 * @type {WebGLRenderTarget}
		 */ this.writeBuffer = this.renderTarget1;
        /**
		 * A reference to the internal read buffer. Passes usually read
		 * the previous render result from this buffer.
		 *
		 * @type {WebGLRenderTarget}
		 */ this.readBuffer = this.renderTarget2;
        /**
		 * Whether the final pass is rendered to the screen (default framebuffer) or not.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.renderToScreen = true;
        /**
		 * An array representing the (ordered) chain of post-processing passes.
		 *
		 * @type {Array<Pass>}
		 */ this.passes = [];
        /**
		 * A copy pass used for internal swap operations.
		 *
		 * @private
		 * @type {ShaderPass}
		 */ this.copyPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$ShaderPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderPass"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$CopyShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CopyShader"]);
        this.copyPass.material.blending = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoBlending"];
        /**
		 * The internal clock for managing time data.
		 *
		 * @private
		 * @type {Clock}
		 */ this.clock = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clock"]();
    }
    /**
	 * Swaps the internal read/write buffers.
	 */ swapBuffers() {
        const tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp;
    }
    /**
	 * Adds the given pass to the pass chain.
	 *
	 * @param {Pass} pass - The pass to add.
	 */ addPass(pass) {
        this.passes.push(pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    /**
	 * Inserts the given pass at a given index.
	 *
	 * @param {Pass} pass - The pass to insert.
	 * @param {number} index - The index into the pass chain.
	 */ insertPass(pass, index) {
        this.passes.splice(index, 0, pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    /**
	 * Removes the given pass from the pass chain.
	 *
	 * @param {Pass} pass - The pass to remove.
	 */ removePass(pass) {
        const index = this.passes.indexOf(pass);
        if (index !== -1) {
            this.passes.splice(index, 1);
        }
    }
    /**
	 * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
	 *
	 * @param {number} passIndex - The pass index.
	 * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.
	 */ isLastEnabledPass(passIndex) {
        for(let i = passIndex + 1; i < this.passes.length; i++){
            if (this.passes[i].enabled) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Executes all enabled post-processing passes in order to produce the final frame.
	 *
	 * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
	 * its own time delta value.
	 */ render(deltaTime) {
        // deltaTime value is in seconds
        if (deltaTime === undefined) {
            deltaTime = this.clock.getDelta();
        }
        const currentRenderTarget = this.renderer.getRenderTarget();
        let maskActive = false;
        for(let i = 0, il = this.passes.length; i < il; i++){
            const pass = this.passes[i];
            if (pass.enabled === false) continue;
            pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
            pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
            if (pass.needsSwap) {
                if (maskActive) {
                    const context = this.renderer.getContext();
                    const stencil = this.renderer.state.buffers.stencil;
                    //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
                    stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
                    this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
                    //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
                    stencil.setFunc(context.EQUAL, 1, 0xffffffff);
                }
                this.swapBuffers();
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$MaskPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MaskPass"] !== undefined) {
                if (pass instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$MaskPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MaskPass"]) {
                    maskActive = true;
                } else if (pass instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$MaskPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClearMaskPass"]) {
                    maskActive = false;
                }
            }
        }
        this.renderer.setRenderTarget(currentRenderTarget);
    }
    /**
	 * Resets the internal state of the EffectComposer.
	 *
	 * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
	 * the one from the constructor. If set, it is used to setup the read and write buffers.
	 */ reset(renderTarget) {
        if (renderTarget === undefined) {
            const size = this.renderer.getSize(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]());
            this._pixelRatio = this.renderer.getPixelRatio();
            this._width = size.width;
            this._height = size.height;
            renderTarget = this.renderTarget1.clone();
            renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
    }
    /**
	 * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
	 * this method honors the current pixel ration.
	 *
	 * @param {number} width - The width in logical pixels.
	 * @param {number} height - The height in logical pixels.
	 */ setSize(width, height) {
        this._width = width;
        this._height = height;
        const effectiveWidth = this._width * this._pixelRatio;
        const effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
        for(let i = 0; i < this.passes.length; i++){
            this.passes[i].setSize(effectiveWidth, effectiveHeight);
        }
    }
    /**
	 * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
	 * Setting the pixel ratio will automatically resize the composer.
	 *
	 * @param {number} pixelRatio - The pixel ratio to set.
	 */ setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
    }
    /**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the composer is no longer used in your app.
	 */ dispose() {
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.copyPass.dispose();
    }
}
;
}),
"[project]/node_modules/three/examples/jsm/postprocessing/RenderPass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderPass",
    ()=>RenderPass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/postprocessing/Pass.js [app-client] (ecmascript)");
;
;
/**
 * This class represents a render pass. It takes a camera and a scene and produces
 * a beauty pass for subsequent post processing effects.
 *
 * ```js
 * const renderPass = new RenderPass( scene, camera );
 * composer.addPass( renderPass );
 * ```
 *
 * @augments Pass
 * @three_import import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 */ class RenderPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pass"] {
    /**
	 * Constructs a new render pass.
	 *
	 * @param {Scene} scene - The scene to render.
	 * @param {Camera} camera - The camera.
	 * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
	 * for all objects in the scene.
	 * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
	 * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
	 */ constructor(scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null){
        super();
        /**
		 * The scene to render.
		 *
		 * @type {Scene}
		 */ this.scene = scene;
        /**
		 * The camera.
		 *
		 * @type {Camera}
		 */ this.camera = camera;
        /**
		 * The override material. If set, this material is used
		 * for all objects in the scene.
		 *
		 * @type {?Material}
		 * @default null
		 */ this.overrideMaterial = overrideMaterial;
        /**
		 * The clear color of the render pass.
		 *
		 * @type {?(number|Color|string)}
		 * @default null
		 */ this.clearColor = clearColor;
        /**
		 * The clear alpha of the render pass.
		 *
		 * @type {?number}
		 * @default null
		 */ this.clearAlpha = clearAlpha;
        /**
		 * Overwritten to perform a clear operation by default.
		 *
		 * @type {boolean}
		 * @default true
		 */ this.clear = true;
        /**
		 * If set to `true`, only the depth can be cleared when `clear` is to `false`.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.clearDepth = false;
        /**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */ this.needsSwap = false;
        /**
		 * This flag indicates that this pass renders the scene itself.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */ this.isRenderPass = true;
        this._oldClearColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
    }
    /**
	 * Performs a beauty pass with the configured scene and camera.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */ render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        let oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== null) {
            oldOverrideMaterial = this.scene.overrideMaterial;
            this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor !== null) {
            renderer.getClearColor(this._oldClearColor);
            renderer.setClearColor(this.clearColor, renderer.getClearAlpha());
        }
        if (this.clearAlpha !== null) {
            oldClearAlpha = renderer.getClearAlpha();
            renderer.setClearAlpha(this.clearAlpha);
        }
        if (this.clearDepth == true) {
            renderer.clearDepth();
        }
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
        if (this.clear === true) {
            // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        }
        renderer.render(this.scene, this.camera);
        // restore
        if (this.clearColor !== null) {
            renderer.setClearColor(this._oldClearColor);
        }
        if (this.clearAlpha !== null) {
            renderer.setClearAlpha(oldClearAlpha);
        }
        if (this.overrideMaterial !== null) {
            this.scene.overrideMaterial = oldOverrideMaterial;
        }
        renderer.autoClear = oldAutoClear;
    }
}
;
}),
]);

//# sourceMappingURL=node_modules_three_examples_jsm_f08cfaa7._.js.map